<document>
  <properties>
    <author email="sven@users.sourceforge.net">Sven Meier</author>
    <title>Spin</title>
  </properties>
  <body>
  <section name="The Problem">
    <subsection name="Standard Swing">
      <p>
        In this section we take a look at a naive GUI implementation that shows how Swing freezes in case the application programmer doesn't take any special actions against it. We also describe the problem of calls into Swing components triggered by any other thread than the event dispatch thread. <br/>
        Swing is not designed for multi threading, so let us first recall the single  threading rule of every Swing GUI:
      </p>
      <blockquote>
        <cite>Access to a (visible) Swing component has to occur in the event dispatch thread.</cite>
      </blockquote>
      <p>
        The event dispatch thread (short EDT) is responsible to process all GUI related events, e.g. notifying listeners of user input, repainting dirty regions or updated areas. All these events are enqueued and treated sequentially - if one of them takes a long time to be processed, all further events will have to wait.
      </p>
      <p>
        In the tables throughout this document the left column represents a Swing GUI component, the right column represents a non visual multithreaded bean that encapsulates extensive calculations. Code run on the EDT is <span class="onEDT">shown in green</span> and code called by any other thread is <span class="offEDT">shown in red</span>.
      </p>
      <p>
        As you can see in the upper half of the following table, the GUI calls the method <code>getValue()</code> on the bean when an action is performed. The event dispatch thread is routed from the GUI to the bean. While it is performing its calculations no further swing events can be processed - the GUI freezes.<br/>
        One of these queued events is the repaint of the label triggered by <code>label.setText("...")</code>. When <code>getValue()</code> returns, the text of the label is changed again before the previous text was painted. So in fact <code>"..."</code> is never seen:
      </p>
      <table border="1" cellpadding="4" cellspacing="0" width="100%">
        <tr valign="top">
          <td width="50%" class="GUI">GUI</td>
          <td width="50%" class="notGUI">BeanImpl</td>
        </tr>
        <tr valign="top">
          <td>
<pre>
public void actionPerformed(ActionEvent e)
{<span class="onEDT">
  label.setText("...");
  label.setText(bean.getValue());
</span>}




public void propertyChange(PropertyChangeEvent ev)
{<span class="offEDT">
  label.setText((String)ev.getNewValue());
</span>}
</pre>
          </td>
          <td>
<pre>
public String getValue()
{<span class="onEDT">
  String value;
  
  // extensive calculation

  return value;
</span>}

public void setValue(String value)
{<span class="offEDT">
  this.value = value;
  firePropertyChange(value);
</span>}
</pre>
          </td>
        </tr>
      </table>
      <p>
        The lower half of the table shows what happens if <code>setValue()</code> is invoked on the bean on another thread. The listeners are notified (GUI implements <code>java.beans.PropertyChangeListener</code> and is registered as a listener for changes of the bean), triggering a call to <code>propertyChange()</code> on the GUI. The text of the label is altered on the calling thread, violating the Swing threading rule.
      </p>
      <p>
        The color distribution gives a hint where to search for problems of this implementation:<br/>
        <span class="onEDT">Green</span> rows of code in the right column result in a GUI freeze, <span class="offEDT">red</span> rows in left column show a violation to the Swing threading rule.
      </p>
    </subsection>
    <subsection name="Working Thread">
      <p>
        One obvious solution to the problems seen in the previous section is to shift the invocation of <code>getValue()</code> from the EDT to a separate thread. When this method returns we must not propagate the result to a Swing component though. We have to return control to the EDT instead. This can be achieved via <code>SwingUtilities.invokeLater()</code> which will use our Runnable to correctly change the label's text on the EDT:
      </p>

      <table border="1" cellpadding="4" cellspacing="0" width="100%">
        <tr valign="top">
          <td width="50%" class="GUI">GUI</td>
          <td width="50%" class="notGUI">BeanImpl</td>
        </tr>
        <tr valign="top">
          <td>
<pre>
public void actionPerformed(ActionEvent e)
{<span class="onEDT">
  label.setText("...");
  new Thread(new Runnable()</span>
  {
    public void run()
    {<span class="offEDT">
      final String value = bean.getValue();
      SwingUtilities.invokeLater(new Runnable()</span>
      {
        public void run()
        {
          <span class="onEDT">label.setText(value);</span>          
        }
      }<span class="offEDT">);</span>
    }
  }<span class="onEDT">).start();</span>
}

public void propertyChange(final PropertyChangeEvent ev)
{
  <span class="offEDT">SwingUtilities.invokeAndWait(new Runnable()</span>
  {
    public void run()
    {
      <span class="onEDT">label.setText((String)ev.getNewValue());</span>        
    }
  }<span class="offEDT">);</span>
}
</pre>
          </td>
          <td>
<pre>
public String getValue()
{<span class="offEDT">
  String value;
  
  // extensive calculation
  
  return value;
</span>}











public void setValue(String value)
{<span class="offEDT">
  this.value = value;
  firePropertyChange(value);
</span>}
</pre>
          </td>
        </tr>
      </table>
      <p>
        Now what happens if the bean informs the GUI about a value-change triggered by another thread? In <code>propertyChange()</code> we pass a runnable to the EDT via <code>SwingUtiltites.invokeAndWait()</code> that can safely alter the label.
      </p>
      <p>
        Let's take a look at the colors once again: On the right there is only <span class="offEDT">red</span> - so we achieved a  non freezing GUI. The left column is <span class="onEDT">almost totally green</span>. Since we  restrict changes to Swing components to these <span class="onEDT">green</span> rows we are honouring the Swing threading rule too.<br/>
        But the <span class="offEDT">red</span> rows on the left make things difficult: The programmer of the GUI always has to know which thread is stepping through what part of the code - without any visual help of thread-coloring. Any mistake reintroduces the problems mentioned above.
      </p>
    </subsection>
    <subsection name="Swingworker">
      <p>
        SwingWorker is a utility class that aims to ease the efforts to write a non-freezing GUI. Although not included in the standard Java distribution it is maintained by the Swing team and downloadable at <a href="http://www.theswingconnection.com">The Swing Connection</a>.
      </p>
      <p>
        As you can see in the following table a SwingWorker removes some of the visual clutter seen in the previous section. To use it you have to subclass it, placing extensive calculations into method <code>construct()</code>. In <code>finished()</code> you can alter the label because this method is called on the EDT. This is similar to our previous solution but this time the threading is handled by the superclass:
      </p>
      <table border="1" cellpadding="4" cellspacing="0" width="100%">
        <tr valign="top">
          <td width="50%" class="GUI">GUI</td>
          <td width="50%" class="notGUI">BeanImpl</td>
        </tr>
        <tr valign="top">
          <td>
<pre>
public void actionPerformed(ActionEvent e)
{<span class="onEDT">
  label.setText("...");
  new SwingWorker()</span>
  {
    public Object construct()
    {
      <span class="offEDT">return bean.getValue();</span>
    }

    public void finished()
    {
      <span class="onEDT">label.setText((String)getValue());</span>
    }
  }<span class="onEDT">).start();</span>
}


public void propertyChange(final PropertyChangeEvent ev)
{
  <span class="offEDT">SwingUtilities.invokeAndWait(new Runnable()</span>
  {
    public void run()
    {
      <span class="onEDT">label.setText((String)ev.getNewValue());</span>        
    }
  }<span class="offEDT">);</span>
}
</pre>
          </td>
          <td>
<pre>
public String getValue()
{<span class="offEDT">
  String value;
  
  // extensive calculation
  
  return value;
</span>}










public void setValue(String value)
{<span class="offEDT">
  this.value = value;
  firePropertyChange(value);
</span>}
</pre>
          </td>
        </tr>
      </table>
      <p>
        The SwingWorker offers no support for our notification problem so we stick to our previous solution in <code>propertyChange()</code>.
      </p>
      <p>
        What about the colors?<br/>
        The situation hasn't really improved. The indentation of code was minimized but the <span class="offEDT">red</span> and <span class="onEDT">green</span> colors in the GUI stay the same. So the problem above isn't resolved yet.
      </p>
    </subsection>
  </section>
  </body>
</document>