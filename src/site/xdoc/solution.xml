<document>
  <properties>
    <author email="sven@users.sourceforge.net">Sven Meier</author>
    <title>Spin</title>
  </properties>
  <body>
  <section name="Solution">
    <subsection name="Spin">
      <p>
        Now let's take a look at the <em>Spin</em> solution. The following table shows the code:
      </p>
      <table border="1" cellpadding="4" cellspacing="0" width="100%">
        <tr valign="top">
          <td>GUI</td>
          <td>BeanImpl</td>
        </tr>
        <tr valign="top">
          <td>
<pre>
public void actionPerformed(ActionEvent e)
{<span class="onEDT">
  label.setText("...");
  label.setText(bean.getValue());
</span>}




public void propertyChange(PropertyChangeEvent ev)
{
  <span class="onEDT">label.setText((String)ev.getNewValue());</span>
}
</pre>
          </td>
          <td>
<pre>
public String getValue()
{<span class="offEDT">
  String value;

  // extensive calculation
  
  return value;
</span>}

public void setValue(String value)
{<span class="offEDT">
  this.value = value;
  firePropertyChange(value);
</span>}
</pre>
          </td>
        </tr>
      </table>
      <p>
        Hey wait a minute! It's the same code as shown in the <a href="problem.html#Standard Swing">standard table</a>. But the colors have changed - the GUI is completely <span class="onEDT">green</span> and the bean is <span class="red">red</span> - how can this be?
      </p>
      <p>
        <em>Spin</em> makes this solution possible - as you can see with no impact on the old code. An invisible column in the middle handles all threading issues transparently.<br/>
        All we have to do is to <em>spin-off</em> the bean from the EDT. For this we wrap the bean in an instance of type <code>Spin</code>. The result can safely be casted to any interface the bean (or one of its superclasses) implements. The best place to do this is before a reference to this bean is passed to a GUI component (why bother the programmer of the GUI with this little detail):
      </p>
<pre>
  bean = (Bean)Spin.off(bean);
</pre>
      <p>   
        The only restriction here is that the Bean has to be broken into interface and implementation. The GUI components will only use the interface! The following picture shows how <em>Spin</em> connects the GUI and the bean. Calls on the EDT from the GUI to the bean are brokered to other threads invocating the beans functionality:
        
        <span class="centeredImage">  
          <img src="images/spinoff.gif" alt="Spin off"/>
        </span>
      </p>
      <p>
        The need for an interface isn't really a restriction:
        <ul>
          <li>
            It is generally recommended to separate an application in different layers which communicate through well defined interfaces. The GUI of an application is certainly part of another layer than extensive calculations or I/O operations.
          </li>
          <li>
            If you don't want to or are unable to use an interface you can <a href="acknowledgement.html#CGLib">utilize CGLib instead of JDK proxies</a>.
          </li>
        </ul>
      </p>
      <p>
        For the notification of changes to the bean we use an inverse technique.<br/>
        We must <em>spin-over</em> any invocation of a GUI callback-method on another thread to the EDT. This time we wrap the GUI in a <code>Spin</code> instance assuming that the bean allows for an <code>PropertyChangeListener</code> to be added as a callback (this could be any interface like foo.DataChangedListener):
      </p>
<pre>
  bean.addPropertyChangeListener((PropertyChangeListener)Spin.over(gui);
</pre>
      <p>  
        <span class="centeredImage">  
          <img src="images/spinover.gif" alt="Spin over"/>
        </span>
      </p>
      <p>
        This is all you have to know to get <em>Spin</em> to work in your project. If you're interested in the internals of <em>Spin</em> go on to the next section.
      </p>
    </subsection>
    <subsection name="Internals">
      <p>
        <em>Spin</em> is built on top of virtual proxies and a technique borrowed from the java.awt.Dialog component. While a modal dialog has to wait for user input, the EDT is rerouted to the swing event processing to handle further events.
      </p>
      <p>
        The following diagram shows how this is used in <em>Spin</em>. Each invocation of a bean's method is intercepted and handled by a    <a href="./apidocs/spin/off/SpinOffEvaluator.html">SpinOffEvaluator</a>:<br/>
        getValue() is evaluated asynchronously on another thread (customizable with a <a href="./apidocs/spin/off/Starter.html">Starter</a>) while Swing events are    dispatched through a <a href="./apidocs/spin/off/Dispatcher.html">Dispatcher</a>. Once the call to the bean returns the dispatching of events is stopped and the EDT is free to return to the standard event processing: 

        <span class="centeredImage">  
          <img src="images/sequencespinoff.gif" alt="Spin off sequence"/>
        </span>
      </p>
      <p>
        For asynchronous notifications from the bean to the GUI we reuse the technique introduced in the previous sections. But this time the call to <code>invokeAndWait()</code> is encapsulated by <em>Spin</em> with a <a href="./apidocs/spin/over/SpinOverEvaluator.html">SpinOverEvaluator</a>:

        <span class="centeredImage">  
        <img src="images/sequencespinover.gif" alt="Spin over sequence"/>
        </span>
      </p>
      <p>  
        Please take a look at the full <a href="./apidocs/index.html">API</a> for details on how to customize <em>Spin</em>.
      </p>
	</subsection>
    <subsection name="Caveats">
      <p>
        Although <em>Spin</em> handles threading transparently there are caveats with <em>spin-off</em> that you should be aware of:
      </p>
      <dl>
        <dt>Security</dt>
        <dd>
          For dispatching <em>Spin</em> needs access to AWT internals that are not available in applets or untrusted JavaWebStart applications due to security restrictions. This will hopefully change once AWT offers an official way to dispatch events.<br/>
          Meanwhile <em>Spin</em> offers alternative solutions which are less performant but also work in a secured environment. Please take a look at <a href="./apidocs/spin/off/DialogDispatcherFactory.html"> DialogDispatcherFactory</a> and <a href="./apidocs/spin/off/InternalOptionPaneDispatcherFactory.html"> InternalOptionPaneDispatcherFactory</a>.
        </dd>
        <dt>Reference backdoor</dt>
        <dd>
          If your GUI hands over references to parts of its swing models (e.g. TreeModel, TableModel) in method calls to your bean, these could possibly be altered on another thread than the EDT thus VIOLATING THE SWING SINGLE THREADING RULE.
        </dd>
        <dt>Bean threadsafety</dt>
        <dd>
          If your GUI doesn't disable all further actions while an invocation on your bean is being processed, the event dispatching may cause a second concurrent call to the bean. In cases where this is desired the BEAN MUST BE THREADSAFE.
        </dd>
        <dt>Asynchronous<a name="asynchronous"/></dt>
        <dd>
          Whenever your GUI calls a beans method through <em>Spin</em>, further actions should be allowed only if they are related to the current <em>Spin</em> invocation. This includes <code>Cancel</code> functionality and the retrieval of the current state of invocation or intermediate results (e.g. for updating a progress bar or incremental filling of a table).<br/>
          You're running into problems if you're using <em>Spin</em> for real asynchronous executions. Let me give an example:<br/>
          File tranfers of an Explorer-like application wich can be arbitrarily started and stopped while others are independently continuing are NOT A RECOMMENDED USAGE for <em>Spin</em>. Nevertheless <em>Spin</em> can be used to <em>spin-over</em> events from the transfers (e.g. completion notification) to the EDT.
        </dd>
        <dt>Incomplete Event Handling</dt>
        <dd>
          An event that triggers <em>Spin</em> will not be completely precessed until the return of the <em>Spin</em> invocation.<br/>
          This might lead to minor visual annoyances, e.g. a JComboBox that does not close its popup or a JButton that stays depressed while <em>Spin</em> is running. But this behaviour could also result in other unexpected behaviours that you should be aware of.<br/>
          Because of this <em>Swing</em> developers have expressed their concern about <em>Spin</em> and similar techniques, stating that '<em>Swing</em> is not completely reentrant'.<br/>
          While this may be true, the same objection could be brought forward against any modal dialog or modal internal frame. If you're using these in your application there is no reason to be afraid of <em>Spin</em>.
        </dd>
      </dl>
    </subsection>    
    <subsection name="Conclusion">
      <p>
        <em>Spin</em> is a small library that concentrates on offering a powerful solution to build non-freezing Swing applications. <em>Spin</em> enforces good application design by separating the GUI and non-visual components through interfaces. If it is used wisely in an application framework, the GUI programmers will never have to think about threads again.
      </p>
      <p>  
        <em>Spin</em> comes with several demonstration classes that show how to solve formerly challenging Swing programming problems with ease:
      </p>
      <ul>
        <li>spin.demo.SpinOffGUI - shows how to execute extensive calculations without "freeze"</li>
        <li>spin.demo.SpinOverGUI - demonstrates asynchronous event notification without pain</li>
        <li>spin.demo.exception.ExceptionGUI - proves the transparent exception handling offered by Spin</li>
        <li>spin.demo.pogress.PullGUI - shows how to handle visual progress while extensive calculations are executed</li>
        <li>spin.demo.pogress.PushGUI - uses asynchronous event notification to update a progressbar</li>
        <li>spin.demo.prompt.CallGUI - explains how to prompt the user between multiple extensive calculations</li>
        <li>spin.demo.prompt.CallbackGUI - prompts the user for input which is triggered by callbacks from an extensive calculation</li>
        <li>spin.demo.async.AsyncGUI - starts asynchronous calculations transparently through Spin</li>
        <li>spin.demo.dispatcher.DispatcherGUI - test different dispatchers</li>
      </ul>   
      <p>  
        We have used <em>Spin</em> successfully in several projects to wrap all remote communication (RMI) between rich-clients and the application server.
      </p>
    </subsection>
  </section>
  </body>
</document>