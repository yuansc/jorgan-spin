<document>
  <properties>
    <author email="sven@users.sourceforge.net">Sven Meier</author>
    <title>Spin</title>
  </properties>
  <body>
    <section name="Standard Swing">
      <p>
        In this section we take a look at a naive GUI implementation that shows how Swing freezes in case the application programmer doesn't take any special actions against it. We also describe the problem of calls into Swing components triggered by any other thread than the event dispatch thread. <br/>
        Swing is not designed for multi threading, so let us first recall the single  threading rule of every Swing GUI:
      </p>
      <blockquote>
        <cite>Access to a (visible) Swing component has to occur in the event dispatch thread.</cite>
      </blockquote>
      <p>
        The event dispatch thread (short EDT) is responsible to process all GUI related events, e.g. notifying listeners of user input, repainting dirty regions or updated areas. All these events are enqueued and treated sequentially - if one of them takes a long time to be processed, all further events will have to wait.
      </p>
      <p>
        In the tables throughout this document the left column represents a Swing GUI component, the right column represents a non visual multithreaded bean that encapsulates extensive calculations. Code run on the EDT is <span class="onEDT">shown in green</span> and code called by any other thread is <span class="offEDT">shown in red</span>.
      </p>
      <p>
        As you can see in the upper half of the following table, the GUI calls the method <code>getValue()</code> on the bean when an action is performed. The event dispatch thread is routed from the GUI to the bean. While it is performing its calculations no further swing events can be processed - the GUI freezes.<br/>
        One of these queued events is the repaint of the label triggered by <code>label.setText("...")</code>. When <code>getValue()</code> returns, the text of the label is changed again before the previous text was painted. So in fact <code>"..."</code> is never seen:
      </p>
      <table border="1" cellpadding="4" cellspacing="0" width="100%">
        <tr valign="top">
          <td width="50%" class="GUI">GUI</td>
          <td width="50%" class="notGUI">BeanImpl</td>
        </tr>
        <tr valign="top">
          <td>
<pre>
public void actionPerformed(ActionEvent e)
{<span class="onEDT">
  label.setText("...");
  label.setText(bean.getValue());
</span>}




public void propertyChange(PropertyChangeEvent ev)
{<span class="offEDT">
  label.setText((String)ev.getNewValue());
</span>}
</pre>
          </td>
          <td>
<pre>
public String getValue()
{<span class="onEDT">
  String value;
  
  // extensive calculation

  return value;
</span>}

public void setValue(String value)
{<span class="offEDT">
  this.value = value;
  firePropertyChange(value);
</span>}
</pre>
          </td>
        </tr>
      </table>
      <p>
        The lower half of the table shows what happens if <code>setValue()</code> is invoked on the bean on another thread. The listeners are notified (GUI implements <code>java.beans.PropertyChangeListener</code> and is registered as a listener for changes of the bean), triggering a call to <code>propertyChange()</code> on the GUI. The text of the label is altered on the calling thread, violating the Swing threading rule.
      </p>
      <p>
        The color distribution gives a hint where to search for problems of this implementation:<br/>
        <span class="onEDT">Green</span> rows of code in the right column result in a GUI freeze, <span class="offEDT">red</span> rows in left column show a violation to the Swing threading rule.
      </p>
    </section>
  </body>
</document>